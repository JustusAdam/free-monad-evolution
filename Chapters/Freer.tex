\section{Performance by means of more freedom}

\label{sec:freer}

Monad transformers have been a part of the Haskell ecosystem for a long time.
They are the de-facto standard method used to implement modular effect systems.
Given how useful and necessary, if not unavoidable, effect systems are for
``real world applictions'' it is not surprising that monad transformers are now
widely used in libraries and even more so in applications and frameworks. being
the biggest player in the game and ubiquitously used comes with benefits for a
library. Namely, in this case, the attention of the compiler writers. According
to Kiselyof and Ishii~\cite{freer-monads} the \texttt{State} monad in particular
enjoys ``preferential treatment by GHC'' as the authors put it, ``with dedicated
optimisation passes''. For an alternative effect system to be effective
therefore it must provide at least comparable performance to the \texttt{mtl}
library, it will not see significant adoption.

The free monad in conjunction with the open union from the previous section is
unable to compete with the \texttt{mtl}. The asymptotic performance of
$\bindOp{}$ is bad and encoding the open union of types with a linked list is
not only slow but also degrades as the number of distinct effects increases,
discouraging modularity and reusability.

\subsection{Efficiency through reflection}

The solution to the latter problem was developed by Kiselyov, Sably and
Swords~\cite{extensible-effects}. They implement a different open union to the
one shown in the section prior. Whereas the interface remains essentially the
same, the class for subeffects changes its name from \texttt{:<:} to
\texttt{Member}, see also figure~\ref{fig:member-class}, the implementation
changes. The open union from the previous section used the height of a stack of
sum types to determine the type of the expression. The new \texttt{Union} type,
as seen in figure~\ref{fig:union-type} uses GHC's reflection mechanism: a
\texttt{TypeRep}. A \texttt{TypeRep} is a runtime representation of a type,
generated by the compiler. It supports fast equality by means of a compiler
generated \emph{fingerprint}. \texttt{prj} attempts to cast the contained type
to the target type, which internally compares the to fingerprints of the
\texttt{TypeRep}'s. Should they match the value can be safely coerced. The
advantage of this reflection based mechanism is that injection as well as
projection are constant time operations, as opposed to linear time, which was
the case with the list-scanning implementation from the previous section.

\subsection{Better asymptotic performance using continuation passing}

As mentioned before the asymptotic performance of $\bindOp$ for the
\texttt{Free} monad is not good. As can be seen in figure~\ref{fig:free-monad}
the implementation for $\bindOp$ pushes the $\bindOp$ down the tree using
\texttt{fmap} until it reaches a \texttt{Pure} value. This means that for every
use of $\bindOp$ the entire tree is traversed once. This problem is akin to
appending to singely linked lists where the entire list has to be traversed to
find the final pointer and append. A solution to this problem was independently
developed in 2008 by Janis Voigtländer~\cite{asymptotic-performance-improvement}
in an attempt to make free monads more efficient. The basic idea is rather
simple and again related to the problem of list appends. For list appends the
solution is the so called \emph{difference list}~\cite{difference-list} which
really is not a list but a function of type \texttt{[a] -> [a]}. This function
will, when called with a list, append it to its end and return the resulting
list. Normal list operations, such as appending and prepending are realised via
function composition. Finally the list can be evaluated in one single step by
passing \texttt{[]} after which the value can be inspected. In imperative
programming this is known as the \emph{builder pattern}. A hole is left to the
end of the list and all altering operations are realised with function
composition.

Asymptotic performance improvement of the free monad employs a similar idea. It
uses a generic structure from category theory, which is now known as the
\emph{Codensity monad}. The original paper by
Voigtländer~\cite{asymptotic-performance-improvement} called it \texttt{C}. The
codensity monad, shown in figure~\ref{fig:codensity-monad}, is also a function
which, given a continuation, builds some monad \texttt{m}. The \emph{extensible
  effects} library, developed by Kiselyov et al~\cite{extensible-effects} this
codensity monad, specialised to a variant of \texttt{Free}. The figure also
shows the new implementation for $\bindOp$ which does not push down the tree
anymore, but builds two lambda functions, which are passed as continuations, a
much cheaper operation in Haskell.

\begin{figure}
  \lstinputlisting[firstline=9]{Listings/Codensity.hs}
  \caption{The codensity monad}
  \label{fig:codensity-monad}
\end{figure}
