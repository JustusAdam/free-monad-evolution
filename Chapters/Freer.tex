\section{A freer monad}

\label{sec:freer}

The ``freer'' effect system brings another advantage over the older ``extensible
effects''. As mentioned in section~\ref{sec:free} the definition of an effect
system requires an effect \texttt{Functor}. This is not strictly true. It is
convenient for the definition of a simple effect system, but can be elided. One
way to do so is using yet another kan extension, a relative of to the
\emph{codensity monad} seen in section~\ref{sec:performance-with-codensity}.
This structure is called the \emph{coyoneda functor} and it is able to lift an
arbitrary \texttt{* $\rightarrow$ *} kinded type to a functor. Simply put it
accumulates alterations applied with \texttt{fmap} in the first field. The
contained structure can be extracted, if a function is provided to apply the
accumulated alterations.

\begin{figure}
  \lstinputlisting[firstline=3]{Listings/Coyoneda.hs}
  \caption{The coyoneda functor}
  \label{fig:coyoneda}
\end{figure}

\begin{figure}
  \lstinputlisting[firstline=3]{Listings/Freer.hs}
  \caption{The augmented free monad with decoupled effect}
  \label{fig:freer-monad}
\end{figure}

While this structure can remove the functor constraint it still couples the
continuation with the effect. Kiselyov and Ishii~\cite{freer} take it one step
further and completely uncouple the two. To achieve this the free monad is
augmented such that the \texttt{Impure} case contains \emph{two} fields, one for
the effect used and one for its continuation as can be seen in
figure~\ref{fig:freer-monad}. In fact only having this decoupled monad is what
enables the use of the type aligned sequence in
section~\ref{sec:type-aligned-sequence}. Since the continuation is no longer
hidden in the effect functor and has a the general structure of \texttt{a
  $\rightarrow$ Eff eff b} it no longer needs to be an actual function, but can
be replaced by something which can be used \emph{like a function}, in case of
the freer monad a sequence of continuations.

Uncoupling effect and continuation results in a much more expressive interface
for effects. Whereas before each effect contained some additional fields for
continuations, now their mere signatures concisely express \emph{what} the
effect actually does. Freer effects use GADTs to express which forms an effect
may assume. Thus an effect is associated with some potential inputs, which are
later passed to the effect handler, via the fields of the effect value, as well
as with the type of the data returned by the effect to the computation via the
type variable parameterising the effect type. For instance in
figure~\ref{fig:console-io-freer} is the console effect from
section~\ref{sec:free} and figure~\ref{fig:console-io-example}. The two
constructors of the effect now describe, in types, what to expect, similar to a
type signature in traditional effectful computations. \texttt{ReadLine} takes no
input and returns a string, indicating that this effect will fetch some
\texttt{String} value \emph{from} the environment, whereas the
\texttt{WriteLine} effect receives a \texttt{String} as input and returns the
unit value, meaning no output is produced, which indicates that a
\texttt{String} value is delivered \emph{to} the environment.

\begin{figure}
  \lstinputlisting[firstline=4]{Listings/ConsoleIOFreer.hs}
  \caption{Freer version of the console IO effect}
  \label{fig:console-io-freer}
\end{figure}

Lastly the handler for an effect no longer has to care about the continuation.
Effect handlers are, in their simplest form, functions of type \texttt{f a $\rightarrow$
  Eff effs a}, where \texttt{f} is the effect type, for instance
\texttt{ConsoleIO}, and \texttt{effs} does not contain \texttt{f} anymore. An
example, how simple such a handler may look, can also be seen in
figure~\ref{fig:console-io-freer}.

With the \texttt{Typeable} requirement gone (see
section~\ref{sec:better-open-union}) as well as the \texttt{Functor} constraint,
expressive effect signatures and simple handlers, the interface for defining and
handling effects becomes small and easy to implement. Complicated effects can be
remapped to standard effects which can be handled generically, such as the
\texttt{State}, \texttt{Reader} or \texttt{Error} effect. The combination of
these features mean that effects are quick and easy to define. This makes it
feasible to implement systems with a much smaller finer effect granularity,
which in turn makes the effect reusable, easier to reason about and test. An
important contributing factor for the viability of this finely granular approach
is the improved performance characteristics as described in the last section.
Due to the linear scaling of freer monads finely granular effect systems can be
employed without having to expect massive performance penalty as would be the
case when using MTL.

An additional feature of the interface of the two systems described in this and
the previous section is that multiple of the same effect can be combined in the
same computation. Namely parameterised effects, such as \texttt{State s}, which
is parameterised over the concrete state type \texttt{s} can occur multiple
times in the effect set, so long as it handles a different \texttt{s}. Thus a
computation of type \texttt{Eff [State Int, State String] a} is possible and
will compute as would be expected. If multiple of identically instantiated
effects are present, for instance \texttt{Eff [State Int, State Int] a}, the
effect closer to the head of the list is handled and used first, then the
latter. This is seldom used in an actual computation, but may occur due to a
handler pushing a new state layer onto the computation, which is subsequently
handles. This type of delegation is highly useful when dealing with complex
custom effects and thus a feature. One slight problem with allowing multiple
types of the same effect is that it becomes more common to have to annotate
polymorphic functions such as \texttt{put} and \texttt{get} with concrete types
to disambiguate the used state type, even if according to the constraints of the
function using it, only one type of state is in scope. However it does afford
finer granularity of effects and composability. Furthermore since defining
custom effects that need no disambiguation is so simple with these systems, it
should not pose problematic.
